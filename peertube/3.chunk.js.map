{"version":3,"sources":["webpack:///./node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js","webpack:///./node_modules/@videojs/vhs-utils/es/stream.js","webpack:///./node_modules/m3u8-parser/dist/m3u8-parser.es.js","webpack:///./node_modules/p2p-media-loader-core/dist/bandwidth-approximator.js","webpack:///./node_modules/p2p-media-loader-core/dist/http-media-manager.js","webpack:///./node_modules/p2p-media-loader-core/dist/hybrid-loader.js","webpack:///./node_modules/p2p-media-loader-core/dist/index.js","webpack:///./node_modules/p2p-media-loader-core/dist/loader-interface.js","webpack:///./node_modules/p2p-media-loader-core/dist/media-peer.js","webpack:///./node_modules/p2p-media-loader-core/dist/p2p-media-manager.js","webpack:///./node_modules/p2p-media-loader-core/dist/segments-memory-storage.js","webpack:///./node_modules/p2p-media-loader-core/dist/stringly-typed-event-emitter.js","webpack:///./node_modules/p2p-media-loader-hlsjs/dist/engine.js","webpack:///./node_modules/p2p-media-loader-hlsjs/dist/hlsjs-loader-class.js","webpack:///./node_modules/p2p-media-loader-hlsjs/dist/hlsjs-loader.js","webpack:///./node_modules/p2p-media-loader-hlsjs/dist/index.js","webpack:///./node_modules/p2p-media-loader-hlsjs/dist/segment-manager.js","webpack:///./node_modules/sha.js/hash.js","webpack:///./node_modules/sha.js/sha1.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAEnC;AACA,SAAS,oDAAM,QAAQ,oDAAM;AAC7B;;AAEe;AACf;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;;AAEA;AACA,C;;;;;;;;;;;;;ACfA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA,qBAAqB,YAAY;AACjC;AACA;AACA,KAAK;AACL;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;;;;;;;;;;;;;ACtHD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACkE;AACb;AACC;AAC4B;AACK;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,2EAAc;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;;AAEA;AACA,CAAC,CAAC,uEAAM;;AAER;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;;AAGL,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,EAAE,2EAAc;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;;;AAGA;;AAEA;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;;AAGL;AACA,oCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;;;AAGA,0CAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAgB,qEAAQ;AACxB;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;;AAEA,+DAA+D,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;;AAEvE;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,OAAO;;;AAGP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,CAAC,uEAAM;;AAER;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,EAAE,2EAAc;;AAEhB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA,eAAe,mFAAsB;AACrC;;;AAGA;AACA,wBAAwB;;AAExB,mBAAmB;;AAEnB;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,2BAA2B;AAC3B;AACA,MAAM;AACN;;AAEA,uEAAuE;;AAEvE,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,6BAA6B;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK,EAAE;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;;;AAGf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA,+EAA+E;AAC/E;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,iBAAiB;AACjB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,0BAA0B,kGAAqB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;;;AAGf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,qEAAQ;AACtB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;;;AAGf;AACA;AACA,wEAAwE;;AAExE;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;;;AAGf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;;;AAGA,6BAA6B,wCAAwC;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;;;AAGX;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA;AACA,WAAW;;;AAGX,mCAAmC;;AAEnC;AACA,SAAS;AACT,qCAAqC;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,CAAC,uEAAM;;AAEmC;;;;;;;;;;;;;AC5+C9B;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,kDAAO;AAC7B,uCAAuC,mBAAO,CAAC,iHAAgC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mFAAmF,aAAa,aAAa;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ja;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,kDAAO;AAC7B,2BAA2B,mBAAO,CAAC,yFAAoB;AACvD,iBAAiB,mBAAO,CAAC,+CAAQ;AACjC,6BAA6B,mBAAO,CAAC,6FAAsB;AAC3D,4BAA4B,mBAAO,CAAC,2FAAqB;AACzD,qBAAqB,mBAAO,CAAC,6EAAc;AAC3C,iCAAiC,mBAAO,CAAC,qGAA0B;AACnE,kCAAkC,mBAAO,CAAC,uGAA2B;AACrE,sBAAsB,mBAAO,CAAC,gEAAiB;AAC/C,aAAa,mBAAO,CAAC,wDAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,sBAAsB,GAAG,iBAAiB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,UAAU;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClZa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,SAAS,mBAAO,CAAC,yFAAoB;AACrC,SAAS,mBAAO,CAAC,mFAAiB;;;;;;;;;;;;;ACvBrB;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iDAAiD;;;;;;;;;;;;;ACtDrC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,kDAAO;AAC7B,uCAAuC,mBAAO,CAAC,iHAAgC;AAC/E,iBAAiB,mBAAO,CAAC,6EAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA,CAAC,iGAAiG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,QAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA,mCAAmC,cAAc,GAAG,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAmD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAmD;AAC7E;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAoD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAA0D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjQa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,kDAAO;AAC7B,eAAe,mBAAO,CAAC,8EAA2B;AAClD,uCAAuC,mBAAO,CAAC,iHAAgC;AAC/E,qBAAqB,mBAAO,CAAC,6EAAc;AAC3C,iBAAiB,mBAAO,CAAC,6EAAQ;AACjC,aAAa,mBAAO,CAAC,kDAAa;AAClC,gBAAgB,mBAAO,CAAC,mEAAS;AACjC;AACA,yEAAyE,sBAAsB;AAC/F,qCAAqC,uBAAuB,GAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAoD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAiD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,aAAa,aAAa;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChWa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2CAA2C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,+CAAQ;AACjC;AACA,yBAAyB,kCAAkC;AAC3D,0BAA0B,mCAAmC;AAC7D;AACA;;;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,+CAAQ;AACjC,gCAAgC,mBAAO,CAAC,iFAAuB;AAC/D,0BAA0B,mBAAO,CAAC,wFAAmB;AACrD,uBAAuB,mBAAO,CAAC,kFAAgB;AAC/C,6BAA6B,mBAAO,CAAC,8FAAsB;AAC3D;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC5Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,yCAAyC;AACzC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAA4E;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA4E;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,SAAS,mBAAO,CAAC,sEAAU;AAC3B,SAAS,mBAAO,CAAC,wFAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;AChIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,iFAAuB;AAC/D,sBAAsB,mBAAO,CAAC,sEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oKAAoK,6BAA6B;AACjM,SAAS;AACT,6BAA6B,iFAAiF;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oFAAoF;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB,GAAG,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAmD;AAC9E;AACA;AACA,4BAA4B,mBAAmB,cAAc,IAAI,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,GAAG,IAAI;AAC5C;;;;;;;;;;;;ACrXA,aAAa,mBAAO,CAAC,wDAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,6DAAU;AACjC,WAAW,mBAAO,CAAC,6CAAQ;AAC3B,aAAa,mBAAO,CAAC,wDAAa;;AAElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB,QAAQ,QAAQ;;AAEhB,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","file":"3.chunk.js","sourcesContent":["import window from 'global/window';\n\nvar atob = function atob(s) {\n  return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nexport default function decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}","/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };","/*! @name m3u8-parser @version 4.6.0 @license Apache-2.0 */\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n\nvar TAB = String.fromCharCode(0x09);\n\nvar parseByterange = function parseByterange(byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  var result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            var subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n\nvar camelCase = function camelCase(str) {\n  return str.toLowerCase().replace(/-(\\w)/g, function (a) {\n    return a[1].toUpperCase();\n  });\n};\n\nvar camelCaseKeys = function camelCaseKeys(attributes) {\n  var result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nvar setHoldBack = function setHoldBack(manifest) {\n  var serverControl = manifest.serverControl,\n      targetDuration = manifest.targetDuration,\n      partTargetDuration = manifest.partTargetDuration;\n\n  if (!serverControl) {\n    return;\n  }\n\n  var tag = '#EXT-X-SERVER-CONTROL';\n  var hb = 'holdBack';\n  var phb = 'partHoldBack';\n  var minTargetDuration = targetDuration && targetDuration * 3;\n  var minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: tag + \" defaulting HOLD-BACK to targetDuration * 3 (\" + minTargetDuration + \").\"\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: tag + \" clamping HOLD-BACK (\" + serverControl[hb] + \") to targetDuration * 3 (\" + minTargetDuration + \")\"\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: tag + \" defaulting PART-HOLD-BACK to partTargetDuration * 3 (\" + serverControl[phb] + \").\"\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: tag + \" clamping PART-HOLD-BACK (\" + serverControl[phb] + \") to partTargetDuration * 2 (\" + minPartDuration + \").\"\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nvar Parser = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_this);\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var hasParts = false;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    var lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    var lastPartByterangeEnd = 0;\n\n    _this.on('end', function () {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && _key) {\n        currentUri.key = _key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      _this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            version: function version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = {\n                  'com.widevine.alpha': {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                  }\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            },\n            'skip': function skip() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n            'part': function part() {\n              var _this2 = this;\n\n              hasParts = true; // parts are always specifed before a segment\n\n              var segmentIndex = this.manifest.segments.length;\n              var part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              var partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(\"#EXT-X-PART #\" + partIndex + \" for segment #\" + segmentIndex, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach(function (r, i) {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    _this2.trigger('warn', {\n                      message: \"#EXT-X-RENDITION-REPORT #\" + i + \" lacks required attribute(s): LAST-PART\"\n                    });\n                  }\n                });\n              }\n            },\n            'server-control': function serverControl() {\n              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n            'preload-hint': function preloadHint() {\n              // parts are always specifed before a segment\n              var segmentIndex = this.manifest.segments.length;\n              var hint = camelCaseKeys(entry.attributes);\n              var isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              var index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(\"#EXT-X-PRELOAD-HINT #\" + index + \" for segment #\" + segmentIndex, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                var otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: \"#EXT-X-PRELOAD-HINT #\" + index + \" for segment #\" + segmentIndex + \" has the same TYPE \" + hint.type + \" as preload hint #\" + i\n                  });\n                }\n              }\n            },\n            'rendition-report': function renditionReport() {\n              var report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              var index = this.manifest.renditionReports.length - 1;\n              var required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(\"#EXT-X-RENDITION-REPORT #\" + index, entry.attributes, required);\n            },\n            'part-inf': function partInf() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // prepare for the next URI\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {\n    var missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: identifier + \" lacks required attribute(s): \" + missing.join(', ')\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n  ;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n  ;\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\nexport { LineStream, ParseStream, Parser };\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SMOOTH_INTERVAL = 1 * 1000;\nconst MEASURE_INTERVAL = 60 * 1000;\nclass NumberWithTime {\n    constructor(value, timeStamp) {\n        this.value = value;\n        this.timeStamp = timeStamp;\n    }\n}\nclass BandwidthApproximator {\n    constructor() {\n        this.lastBytes = [];\n        this.currentBytesSum = 0;\n        this.lastBandwidth = [];\n    }\n    addBytes(bytes, timeStamp) {\n        this.lastBytes.push(new NumberWithTime(bytes, timeStamp));\n        this.currentBytesSum += bytes;\n        while (timeStamp - this.lastBytes[0].timeStamp > SMOOTH_INTERVAL) {\n            this.currentBytesSum -= this.lastBytes.shift().value;\n        }\n        this.lastBandwidth.push(new NumberWithTime(this.currentBytesSum / SMOOTH_INTERVAL, timeStamp));\n    }\n    // in bytes per millisecond\n    getBandwidth(timeStamp) {\n        while (this.lastBandwidth.length != 0 && timeStamp - this.lastBandwidth[0].timeStamp > MEASURE_INTERVAL) {\n            this.lastBandwidth.shift();\n        }\n        let maxBandwidth = 0;\n        for (const bandwidth of this.lastBandwidth) {\n            if (bandwidth.value > maxBandwidth) {\n                maxBandwidth = bandwidth.value;\n            }\n        }\n        return maxBandwidth;\n    }\n    getSmoothInterval() {\n        return SMOOTH_INTERVAL;\n    }\n    getMeasureInterval() {\n        return MEASURE_INTERVAL;\n    }\n}\nexports.BandwidthApproximator = BandwidthApproximator;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Debug = require(\"debug\");\nconst stringly_typed_event_emitter_1 = require(\"./stringly-typed-event-emitter\");\nclass HttpMediaManager extends stringly_typed_event_emitter_1.STEEmitter {\n    constructor(settings) {\n        super();\n        this.settings = settings;\n        this.xhrRequests = new Map();\n        this.failedSegments = new Map();\n        this.debug = Debug(\"p2pml:http-media-manager\");\n        this.now = () => performance.now();\n    }\n    download(segment, downloadedPieces) {\n        if (this.isDownloading(segment)) {\n            return;\n        }\n        this.cleanTimedOutFailedSegments();\n        const segmentUrl = this.settings.segmentUrlBuilder\n            ? this.settings.segmentUrlBuilder(segment)\n            : segment.url;\n        this.debug(\"http segment download\", segmentUrl);\n        segment.requestUrl = segmentUrl;\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", segmentUrl, true);\n        xhr.responseType = \"arraybuffer\";\n        if (segment.range) {\n            xhr.setRequestHeader(\"Range\", segment.range);\n            downloadedPieces = undefined; // TODO: process downloadedPieces for segments with range headers too\n        }\n        else if ((downloadedPieces !== undefined) && this.settings.httpUseRanges) {\n            let bytesDownloaded = 0;\n            for (const piece of downloadedPieces) {\n                bytesDownloaded += piece.byteLength;\n            }\n            xhr.setRequestHeader(\"Range\", `bytes=${bytesDownloaded}-`);\n            this.debug(\"continue download from\", bytesDownloaded);\n        }\n        else {\n            downloadedPieces = undefined;\n        }\n        this.setupXhrEvents(xhr, segment, downloadedPieces);\n        if (this.settings.xhrSetup) {\n            this.settings.xhrSetup(xhr, segmentUrl);\n        }\n        this.xhrRequests.set(segment.id, { xhr, segment });\n        xhr.send();\n    }\n    abort(segment) {\n        const request = this.xhrRequests.get(segment.id);\n        if (request) {\n            request.xhr.abort();\n            this.xhrRequests.delete(segment.id);\n            this.debug(\"http segment abort\", segment.id);\n        }\n    }\n    isDownloading(segment) {\n        return this.xhrRequests.has(segment.id);\n    }\n    isFailed(segment) {\n        const time = this.failedSegments.get(segment.id);\n        return time !== undefined && time > this.now();\n    }\n    getActiveDownloads() {\n        return this.xhrRequests;\n    }\n    getActiveDownloadsCount() {\n        return this.xhrRequests.size;\n    }\n    destroy() {\n        this.xhrRequests.forEach(request => request.xhr.abort());\n        this.xhrRequests.clear();\n    }\n    setupXhrEvents(xhr, segment, downloadedPieces) {\n        let prevBytesLoaded = 0;\n        xhr.addEventListener(\"progress\", (event) => {\n            const bytesLoaded = event.loaded - prevBytesLoaded;\n            this.emit(\"bytes-downloaded\", bytesLoaded);\n            prevBytesLoaded = event.loaded;\n        });\n        xhr.addEventListener(\"load\", async (event) => {\n            if ((event.target.status < 200) || (event.target.status >= 300)) {\n                this.segmentFailure(segment, event, xhr);\n                return;\n            }\n            let data = event.target.response;\n            if ((downloadedPieces !== undefined) && (event.target.status === 206)) {\n                let bytesDownloaded = 0;\n                for (const piece of downloadedPieces) {\n                    bytesDownloaded += piece.byteLength;\n                }\n                const segmentData = new Uint8Array(bytesDownloaded + data.byteLength);\n                let offset = 0;\n                for (const piece of downloadedPieces) {\n                    segmentData.set(new Uint8Array(piece), offset);\n                    offset += piece.byteLength;\n                }\n                segmentData.set(new Uint8Array(data), offset);\n                data = segmentData.buffer;\n            }\n            await this.segmentDownloadFinished(segment, data, xhr);\n        });\n        xhr.addEventListener(\"error\", (event) => {\n            this.segmentFailure(segment, event, xhr);\n        });\n        xhr.addEventListener(\"timeout\", (event) => {\n            this.segmentFailure(segment, event, xhr);\n        });\n    }\n    async segmentDownloadFinished(segment, data, xhr) {\n        segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;\n        if (this.settings.segmentValidator) {\n            try {\n                await this.settings.segmentValidator(Object.assign(Object.assign({}, segment), { data: data }), \"http\");\n            }\n            catch (error) {\n                this.debug(\"segment validator failed\", error);\n                this.segmentFailure(segment, error, xhr);\n                return;\n            }\n        }\n        this.xhrRequests.delete(segment.id);\n        this.emit(\"segment-loaded\", segment, data);\n    }\n    segmentFailure(segment, error, xhr) {\n        segment.responseUrl = xhr.responseURL === null ? undefined : xhr.responseURL;\n        this.xhrRequests.delete(segment.id);\n        this.failedSegments.set(segment.id, this.now() + this.settings.httpFailedSegmentTimeout);\n        this.emit(\"segment-error\", segment, error);\n    }\n    cleanTimedOutFailedSegments() {\n        const now = this.now();\n        const candidates = [];\n        this.failedSegments.forEach((time, id) => {\n            if (time < now) {\n                candidates.push(id);\n            }\n        });\n        candidates.forEach(id => this.failedSegments.delete(id));\n    }\n}\nexports.HttpMediaManager = HttpMediaManager;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Debug = require(\"debug\");\nconst loader_interface_1 = require(\"./loader-interface\");\nconst events_1 = require(\"events\");\nconst http_media_manager_1 = require(\"./http-media-manager\");\nconst p2p_media_manager_1 = require(\"./p2p-media-manager\");\nconst media_peer_1 = require(\"./media-peer\");\nconst bandwidth_approximator_1 = require(\"./bandwidth-approximator\");\nconst segments_memory_storage_1 = require(\"./segments-memory-storage\");\nconst getBrowserRTC = require(\"get-browser-rtc\");\nconst Peer = require(\"simple-peer\");\nconst defaultSettings = {\n    cachedSegmentExpiration: 5 * 60 * 1000,\n    cachedSegmentsCount: 30,\n    useP2P: true,\n    consumeOnly: false,\n    requiredSegmentsPriority: 1,\n    simultaneousHttpDownloads: 2,\n    httpDownloadProbability: 0.1,\n    httpDownloadProbabilityInterval: 1000,\n    httpDownloadProbabilitySkipIfNoPeers: false,\n    httpFailedSegmentTimeout: 10000,\n    httpDownloadMaxPriority: 20,\n    httpDownloadInitialTimeout: 0,\n    httpDownloadInitialTimeoutPerSegment: 4000,\n    httpUseRanges: false,\n    simultaneousP2PDownloads: 3,\n    p2pDownloadMaxPriority: 20,\n    p2pSegmentDownloadTimeout: 60000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    trackerAnnounce: [\"wss://tracker.novage.com.ua\", \"wss://tracker.openwebtorrent.com\"],\n    peerRequestsPerAnnounce: 10,\n    rtcConfig: Peer.config\n};\nclass HybridLoader extends events_1.EventEmitter {\n    constructor(settings = {}) {\n        super();\n        this.debug = Debug(\"p2pml:hybrid-loader\");\n        this.debugSegments = Debug(\"p2pml:hybrid-loader-segments\");\n        this.segmentsQueue = [];\n        this.bandwidthApproximator = new bandwidth_approximator_1.BandwidthApproximator();\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n        this.processInitialSegmentTimeout = async () => {\n            if (this.httpRandomDownloadInterval === undefined) {\n                return; // Instance destroyed\n            }\n            if (this.masterSwarmId !== undefined) {\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n                }\n            }\n            if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n                // Set one more timeout for a next segment\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment);\n            }\n        };\n        this.downloadRandomSegmentOverHttp = async () => {\n            if (this.masterSwarmId === undefined ||\n                this.httpRandomDownloadInterval === undefined ||\n                this.httpDownloadInitialTimeoutTimestamp !== -Infinity ||\n                this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads ||\n                (this.settings.httpDownloadProbabilitySkipIfNoPeers && this.p2pManager.getPeers().size === 0) ||\n                this.settings.consumeOnly) {\n                return;\n            }\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            const segmentsMap = this.p2pManager.getOvrallSegmentsMap();\n            const pendingQueue = this.segmentsQueue.filter(s => !this.p2pManager.isDownloading(s) &&\n                !this.httpManager.isDownloading(s) &&\n                !segmentsMap.has(s.id) &&\n                !this.httpManager.isFailed(s) &&\n                (s.priority <= this.settings.httpDownloadMaxPriority) &&\n                !storageSegments.has(s.id));\n            if (pendingQueue.length == 0) {\n                return;\n            }\n            if (Math.random() > this.settings.httpDownloadProbability * pendingQueue.length) {\n                return;\n            }\n            const segment = pendingQueue[Math.floor(Math.random() * pendingQueue.length)];\n            this.debugSegments(\"HTTP download (random)\", segment.priority, segment.url);\n            this.httpManager.download(segment);\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        };\n        this.onPieceBytesDownloaded = (method, bytes, peerId) => {\n            this.bandwidthApproximator.addBytes(bytes, this.now());\n            this.emit(loader_interface_1.Events.PieceBytesDownloaded, method, bytes, peerId);\n        };\n        this.onPieceBytesUploaded = (method, bytes, peerId) => {\n            this.emit(loader_interface_1.Events.PieceBytesUploaded, method, bytes, peerId);\n        };\n        this.onSegmentLoaded = async (segment, data, peerId) => {\n            this.debugSegments(\"segment loaded\", segment.id, segment.url);\n            if (this.masterSwarmId === undefined) {\n                return;\n            }\n            segment.data = data;\n            segment.downloadBandwidth = this.bandwidthApproximator.getBandwidth(this.now());\n            await this.segmentsStorage.storeSegment(segment);\n            this.emit(loader_interface_1.Events.SegmentLoaded, segment, peerId);\n            let storageSegments;\n            storageSegments = (storageSegments === undefined ? await this.segmentsStorage.getSegmentsMap(this.masterSwarmId) : storageSegments);\n            this.processSegmentsQueue(storageSegments);\n            if (!this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        };\n        this.onSegmentError = async (segment, details, peerId) => {\n            this.debugSegments(\"segment error\", segment.id, segment.url, peerId, details);\n            this.emit(loader_interface_1.Events.SegmentError, segment, details, peerId);\n            if (this.masterSwarmId !== undefined) {\n                const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n                if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                    this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n                }\n            }\n        };\n        this.onPeerConnect = async (peer) => {\n            this.emit(loader_interface_1.Events.PeerConnect, peer);\n            if (!this.settings.consumeOnly && this.masterSwarmId !== undefined) {\n                this.p2pManager.sendSegmentsMap(peer.id, this.createSegmentsMap(await this.segmentsStorage.getSegmentsMap(this.masterSwarmId)));\n            }\n        };\n        this.onPeerClose = (peerId) => {\n            this.emit(loader_interface_1.Events.PeerClose, peerId);\n        };\n        this.onTrackerUpdate = async (data) => {\n            if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity &&\n                data.incomplete !== undefined && data.incomplete <= 1) {\n                this.debugSegments(\"cancel initial HTTP download timeout - no peers\");\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n                if (this.masterSwarmId !== undefined) {\n                    const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n                    if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                        this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n                    }\n                }\n            }\n        };\n        this.settings = Object.assign(Object.assign({}, defaultSettings), settings);\n        if (settings.bufferedSegmentsCount) {\n            if (settings.p2pDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = settings.bufferedSegmentsCount;\n            }\n            if (settings.httpDownloadMaxPriority === undefined) {\n                this.settings.p2pDownloadMaxPriority = settings.bufferedSegmentsCount;\n            }\n            delete this.settings.bufferedSegmentsCount;\n        }\n        this.segmentsStorage = (this.settings.segmentsStorage === undefined\n            ? new segments_memory_storage_1.SegmentsMemoryStorage(this.settings)\n            : this.settings.segmentsStorage);\n        this.debug(\"loader settings\", this.settings);\n        this.httpManager = this.createHttpManager();\n        this.httpManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.httpManager.on(\"segment-error\", this.onSegmentError);\n        this.httpManager.on(\"bytes-downloaded\", (bytes) => this.onPieceBytesDownloaded(\"http\", bytes));\n        this.p2pManager = this.createP2PManager();\n        this.p2pManager.on(\"segment-loaded\", this.onSegmentLoaded);\n        this.p2pManager.on(\"segment-error\", this.onSegmentError);\n        this.p2pManager.on(\"peer-data-updated\", async () => {\n            if (this.masterSwarmId === undefined) {\n                return;\n            }\n            const storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            if (this.processSegmentsQueue(storageSegments) && !this.settings.consumeOnly) {\n                this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n            }\n        });\n        this.p2pManager.on(\"bytes-downloaded\", (bytes, peerId) => this.onPieceBytesDownloaded(\"p2p\", bytes, peerId));\n        this.p2pManager.on(\"bytes-uploaded\", (bytes, peerId) => this.onPieceBytesUploaded(\"p2p\", bytes, peerId));\n        this.p2pManager.on(\"peer-connected\", this.onPeerConnect);\n        this.p2pManager.on(\"peer-closed\", this.onPeerClose);\n        this.p2pManager.on(\"tracker-update\", this.onTrackerUpdate);\n    }\n    static isSupported() {\n        const browserRtc = getBrowserRTC();\n        return (browserRtc && (browserRtc.RTCPeerConnection.prototype.createDataChannel !== undefined));\n    }\n    createHttpManager() {\n        return new http_media_manager_1.HttpMediaManager(this.settings);\n    }\n    createP2PManager() {\n        return new p2p_media_manager_1.P2PMediaManager(this.segmentsStorage, this.settings);\n    }\n    async load(segments, streamSwarmId) {\n        if (this.httpRandomDownloadInterval === undefined) { // Do once on first call\n            this.httpRandomDownloadInterval = setInterval(this.downloadRandomSegmentOverHttp, this.settings.httpDownloadProbabilityInterval);\n            if (this.settings.httpDownloadInitialTimeout > 0 && this.settings.httpDownloadInitialTimeoutPerSegment > 0) {\n                // Initialize initial HTTP download timeout (i.e. download initial segments over P2P)\n                this.debugSegments(\"enable initial HTTP download timeout\", this.settings.httpDownloadInitialTimeout, \"per segment\", this.settings.httpDownloadInitialTimeoutPerSegment);\n                this.httpDownloadInitialTimeoutTimestamp = this.now();\n                setTimeout(this.processInitialSegmentTimeout, this.settings.httpDownloadInitialTimeoutPerSegment + 100);\n            }\n        }\n        if (segments.length > 0) {\n            this.masterSwarmId = segments[0].masterSwarmId;\n        }\n        if (this.masterSwarmId !== undefined) {\n            this.p2pManager.setStreamSwarmId(streamSwarmId, this.masterSwarmId);\n        }\n        this.debug(\"load segments\");\n        let updateSegmentsMap = false;\n        // stop all http requests and p2p downloads for segments that are not in the new load\n        for (const segment of this.segmentsQueue) {\n            if (!segments.find(f => f.url == segment.url)) {\n                this.debug(\"remove segment\", segment.url);\n                if (this.httpManager.isDownloading(segment)) {\n                    updateSegmentsMap = true;\n                    this.httpManager.abort(segment);\n                }\n                else {\n                    this.p2pManager.abort(segment);\n                }\n                this.emit(loader_interface_1.Events.SegmentAbort, segment);\n            }\n        }\n        if (this.debug.enabled) {\n            for (const segment of segments) {\n                if (!this.segmentsQueue.find(f => f.url == segment.url)) {\n                    this.debug(\"add segment\", segment.url);\n                }\n            }\n        }\n        this.segmentsQueue = segments;\n        if (this.masterSwarmId === undefined) {\n            return;\n        }\n        let storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n        updateSegmentsMap = (this.processSegmentsQueue(storageSegments) || updateSegmentsMap);\n        if (await this.cleanSegmentsStorage()) {\n            storageSegments = await this.segmentsStorage.getSegmentsMap(this.masterSwarmId);\n            updateSegmentsMap = true;\n        }\n        if (updateSegmentsMap && !this.settings.consumeOnly) {\n            this.p2pManager.sendSegmentsMapToAll(this.createSegmentsMap(storageSegments));\n        }\n    }\n    async getSegment(id) {\n        return this.masterSwarmId === undefined\n            ? undefined\n            : this.segmentsStorage.getSegment(id, this.masterSwarmId);\n    }\n    getSettings() {\n        return this.settings;\n    }\n    getDetails() {\n        return {\n            peerId: this.p2pManager.getPeerId()\n        };\n    }\n    async destroy() {\n        if (this.httpRandomDownloadInterval !== undefined) {\n            clearInterval(this.httpRandomDownloadInterval);\n            this.httpRandomDownloadInterval = undefined;\n        }\n        this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n        this.segmentsQueue = [];\n        this.httpManager.destroy();\n        this.p2pManager.destroy();\n        this.masterSwarmId = undefined;\n        await this.segmentsStorage.destroy();\n    }\n    processSegmentsQueue(storageSegments) {\n        this.debugSegments(\"process segments queue. priority\", this.segmentsQueue.length > 0 ? this.segmentsQueue[0].priority : 0);\n        if (this.masterSwarmId === undefined || this.segmentsQueue.length === 0) {\n            return false;\n        }\n        let updateSegmentsMap = false;\n        let segmentsMap;\n        let httpAllowed = true;\n        if (this.httpDownloadInitialTimeoutTimestamp !== -Infinity) {\n            let firstNotDownloadePriority;\n            for (const segment of this.segmentsQueue) {\n                if (!storageSegments.has(segment.id)) {\n                    firstNotDownloadePriority = segment.priority;\n                    break;\n                }\n            }\n            const httpTimeout = this.now() - this.httpDownloadInitialTimeoutTimestamp;\n            httpAllowed = (httpTimeout >= this.settings.httpDownloadInitialTimeout)\n                || ((firstNotDownloadePriority !== undefined) && (httpTimeout > this.settings.httpDownloadInitialTimeoutPerSegment) && (firstNotDownloadePriority <= 0));\n            if (httpAllowed) {\n                this.debugSegments(\"cancel initial HTTP download timeout - timed out\");\n                this.httpDownloadInitialTimeoutTimestamp = -Infinity;\n            }\n        }\n        for (let index = 0; index < this.segmentsQueue.length; index++) {\n            const segment = this.segmentsQueue[index];\n            if (storageSegments.has(segment.id) || this.httpManager.isDownloading(segment)) {\n                continue;\n            }\n            if (segment.priority <= this.settings.requiredSegmentsPriority && httpAllowed && !this.httpManager.isFailed(segment)) {\n                // Download required segments over HTTP\n                if (this.httpManager.getActiveDownloadsCount() >= this.settings.simultaneousHttpDownloads) {\n                    // Not enough HTTP download resources. Abort one of the HTTP downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.httpManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel HTTP download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.httpManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n                if (this.httpManager.getActiveDownloadsCount() < this.settings.simultaneousHttpDownloads) {\n                    // Abort P2P download of the required segment if any and force HTTP download\n                    const downloadedPieces = this.p2pManager.abort(segment);\n                    this.httpManager.download(segment, downloadedPieces);\n                    this.debugSegments(\"HTTP download (priority)\", segment.priority, segment.url);\n                    updateSegmentsMap = true;\n                    continue;\n                }\n            }\n            if (this.p2pManager.isDownloading(segment)) {\n                continue;\n            }\n            if (segment.priority <= this.settings.requiredSegmentsPriority) { // Download required segments over P2P\n                segmentsMap = segmentsMap ? segmentsMap : this.p2pManager.getOvrallSegmentsMap();\n                if (segmentsMap.get(segment.id) !== media_peer_1.MediaPeerSegmentStatus.Loaded) {\n                    continue;\n                }\n                if (this.p2pManager.getActiveDownloadsCount() >= this.settings.simultaneousP2PDownloads) {\n                    // Not enough P2P download resources. Abort one of the P2P downloads.\n                    for (let i = this.segmentsQueue.length - 1; i > index; i--) {\n                        const segmentToAbort = this.segmentsQueue[i];\n                        if (this.p2pManager.isDownloading(segmentToAbort)) {\n                            this.debugSegments(\"cancel P2P download\", segmentToAbort.priority, segmentToAbort.url);\n                            this.p2pManager.abort(segmentToAbort);\n                            break;\n                        }\n                    }\n                }\n                if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads) {\n                    if (this.p2pManager.download(segment)) {\n                        this.debugSegments(\"P2P download (priority)\", segment.priority, segment.url);\n                        continue;\n                    }\n                }\n                continue;\n            }\n            if (this.p2pManager.getActiveDownloadsCount() < this.settings.simultaneousP2PDownloads &&\n                segment.priority <= this.settings.p2pDownloadMaxPriority) {\n                if (this.p2pManager.download(segment)) {\n                    this.debugSegments(\"P2P download\", segment.priority, segment.url);\n                }\n            }\n        }\n        return updateSegmentsMap;\n    }\n    getStreamSwarmId(segment) {\n        return segment.streamId === undefined ? segment.masterSwarmId : `${segment.masterSwarmId}+${segment.streamId}`;\n    }\n    createSegmentsMap(storageSegments) {\n        const segmentsMap = {};\n        const addSegmentToMap = (segment, status) => {\n            const streamSwarmId = this.getStreamSwarmId(segment);\n            const segmentId = segment.sequence;\n            let segmentsIdsAndStatuses = segmentsMap[streamSwarmId];\n            if (segmentsIdsAndStatuses === undefined) {\n                segmentsIdsAndStatuses = [\"\", []];\n                segmentsMap[streamSwarmId] = segmentsIdsAndStatuses;\n            }\n            const segmentsStatuses = segmentsIdsAndStatuses[1];\n            segmentsIdsAndStatuses[0] += ((segmentsStatuses.length == 0) ? segmentId : `|${segmentId}`);\n            segmentsStatuses.push(status);\n        };\n        for (const storageSegment of storageSegments.values()) {\n            addSegmentToMap(storageSegment.segment, media_peer_1.MediaPeerSegmentStatus.Loaded);\n        }\n        for (const download of this.httpManager.getActiveDownloads().values()) {\n            addSegmentToMap(download.segment, media_peer_1.MediaPeerSegmentStatus.LoadingByHttp);\n        }\n        return segmentsMap;\n    }\n    async cleanSegmentsStorage() {\n        if (this.masterSwarmId === undefined) {\n            return false;\n        }\n        return this.segmentsStorage.clean(this.masterSwarmId, (id) => this.segmentsQueue.find(queueSegment => queueSegment.id === id) !== undefined);\n    }\n    now() {\n        return performance.now();\n    }\n}\nexports.HybridLoader = HybridLoader;\n","\"use strict\";\n/**\n * @license Apache-2.0\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = \"0.6.2\";\n__export(require(\"./loader-interface\"));\n__export(require(\"./hybrid-loader\"));\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Events;\n(function (Events) {\n    /**\n     * Emitted when segment has been downloaded.\n     * Args: segment\n     */\n    Events[\"SegmentLoaded\"] = \"segment_loaded\";\n    /**\n     * Emitted when an error occurred while loading the segment.\n     * Args: segment, error\n     */\n    Events[\"SegmentError\"] = \"segment_error\";\n    /**\n     * Emitted for each segment that does not hit into a new segments queue when the load() method is called.\n     * Args: segment\n     */\n    Events[\"SegmentAbort\"] = \"segment_abort\";\n    /**\n     * Emitted when a peer is connected.\n     * Args: peer\n     */\n    Events[\"PeerConnect\"] = \"peer_connect\";\n    /**\n     * Emitted when a peer is disconnected.\n     * Args: peerId\n     */\n    Events[\"PeerClose\"] = \"peer_close\";\n    /**\n     * Emitted when a segment piece has been downloaded.\n     * Args: method (can be \"http\" or \"p2p\" only), bytes\n     */\n    Events[\"PieceBytesDownloaded\"] = \"piece_bytes_downloaded\";\n    /**\n     * Emitted when a segment piece has been uploaded.\n     * Args: method (can be \"p2p\" only), bytes\n     */\n    Events[\"PieceBytesUploaded\"] = \"piece_bytes_uploaded\";\n})(Events = exports.Events || (exports.Events = {}));\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Debug = require(\"debug\");\nconst stringly_typed_event_emitter_1 = require(\"./stringly-typed-event-emitter\");\nconst buffer_1 = require(\"buffer\");\nvar MediaPeerCommands;\n(function (MediaPeerCommands) {\n    MediaPeerCommands[MediaPeerCommands[\"SegmentData\"] = 0] = \"SegmentData\";\n    MediaPeerCommands[MediaPeerCommands[\"SegmentAbsent\"] = 1] = \"SegmentAbsent\";\n    MediaPeerCommands[MediaPeerCommands[\"SegmentsMap\"] = 2] = \"SegmentsMap\";\n    MediaPeerCommands[MediaPeerCommands[\"SegmentRequest\"] = 3] = \"SegmentRequest\";\n    MediaPeerCommands[MediaPeerCommands[\"CancelSegmentRequest\"] = 4] = \"CancelSegmentRequest\";\n})(MediaPeerCommands || (MediaPeerCommands = {}));\nvar MediaPeerSegmentStatus;\n(function (MediaPeerSegmentStatus) {\n    MediaPeerSegmentStatus[MediaPeerSegmentStatus[\"Loaded\"] = 0] = \"Loaded\";\n    MediaPeerSegmentStatus[MediaPeerSegmentStatus[\"LoadingByHttp\"] = 1] = \"LoadingByHttp\";\n})(MediaPeerSegmentStatus = exports.MediaPeerSegmentStatus || (exports.MediaPeerSegmentStatus = {}));\nclass DownloadingSegment {\n    constructor(id, size) {\n        this.id = id;\n        this.size = size;\n        this.bytesDownloaded = 0;\n        this.pieces = [];\n    }\n}\nclass MediaPeer extends stringly_typed_event_emitter_1.STEEmitter {\n    constructor(peer, settings) {\n        super();\n        this.peer = peer;\n        this.settings = settings;\n        this.remoteAddress = \"\";\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.segmentsMap = new Map();\n        this.debug = Debug(\"p2pml:media-peer\");\n        this.timer = null;\n        this.onPeerConnect = () => {\n            this.debug(\"peer connect\", this.id, this);\n            this.remoteAddress = this.peer.remoteAddress;\n            this.emit(\"connect\", this);\n        };\n        this.onPeerClose = () => {\n            this.debug(\"peer close\", this.id, this);\n            this.terminateSegmentRequest();\n            this.emit(\"close\", this);\n        };\n        this.onPeerError = (error) => {\n            this.debug(\"peer error\", this.id, error, this);\n        };\n        this.onPeerData = (data) => {\n            const command = this.getJsonCommand(data);\n            if (command == null) {\n                this.receiveSegmentPiece(data);\n                return;\n            }\n            if (this.downloadingSegment) {\n                this.debug(\"peer segment download is interrupted by a command\", this.id, this);\n                const segmentId = this.downloadingSegment.id;\n                this.terminateSegmentRequest();\n                this.emit(\"segment-error\", this, segmentId, \"Segment download is interrupted by a command\");\n                return;\n            }\n            this.debug(\"peer receive command\", this.id, command, this);\n            switch (command.c) {\n                case MediaPeerCommands.SegmentsMap:\n                    this.segmentsMap = this.createSegmentsMap(command.m);\n                    this.emit(\"data-updated\");\n                    break;\n                case MediaPeerCommands.SegmentRequest:\n                    this.emit(\"segment-request\", this, command.i);\n                    break;\n                case MediaPeerCommands.SegmentData:\n                    if (this.downloadingSegmentId === command.i) {\n                        this.downloadingSegment = new DownloadingSegment(command.i, command.s);\n                        this.cancelResponseTimeoutTimer();\n                    }\n                    break;\n                case MediaPeerCommands.SegmentAbsent:\n                    if (this.downloadingSegmentId === command.i) {\n                        this.terminateSegmentRequest();\n                        this.segmentsMap.delete(command.i);\n                        this.emit(\"segment-absent\", this, command.i);\n                    }\n                    break;\n                case MediaPeerCommands.CancelSegmentRequest:\n                    // TODO: peer stop sending buffer\n                    break;\n                default:\n                    break;\n            }\n        };\n        this.peer.on(\"connect\", this.onPeerConnect);\n        this.peer.on(\"close\", this.onPeerClose);\n        this.peer.on(\"error\", this.onPeerError);\n        this.peer.on(\"data\", this.onPeerData);\n        this.id = peer.id;\n    }\n    receiveSegmentPiece(data) {\n        if (!this.downloadingSegment) {\n            // The segment was not requested or canceled\n            this.debug(\"peer segment not requested\", this.id, this);\n            return;\n        }\n        this.downloadingSegment.bytesDownloaded += data.byteLength;\n        this.downloadingSegment.pieces.push(data);\n        this.emit(\"bytes-downloaded\", this, data.byteLength);\n        const segmentId = this.downloadingSegment.id;\n        if (this.downloadingSegment.bytesDownloaded == this.downloadingSegment.size) {\n            const segmentData = new Uint8Array(this.downloadingSegment.size);\n            let offset = 0;\n            for (const piece of this.downloadingSegment.pieces) {\n                segmentData.set(new Uint8Array(piece), offset);\n                offset += piece.byteLength;\n            }\n            this.debug(\"peer segment download done\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-loaded\", this, segmentId, segmentData.buffer);\n        }\n        else if (this.downloadingSegment.bytesDownloaded > this.downloadingSegment.size) {\n            this.debug(\"peer segment download bytes mismatch\", this.id, segmentId, this);\n            this.terminateSegmentRequest();\n            this.emit(\"segment-error\", this, segmentId, \"Too many bytes received for segment\");\n        }\n    }\n    getJsonCommand(data) {\n        const bytes = new Uint8Array(data);\n        // Serialized JSON string check by first, second and last characters: '{\" .... }'\n        if (bytes[0] == 123 && bytes[1] == 34 && bytes[data.byteLength - 1] == 125) {\n            try {\n                return JSON.parse(new TextDecoder().decode(data));\n            }\n            catch (_a) {\n            }\n        }\n        return null;\n    }\n    createSegmentsMap(segments) {\n        if (segments == undefined || !(segments instanceof Object)) {\n            return new Map();\n        }\n        const segmentsMap = new Map();\n        for (const streamSwarmId of Object.keys(segments)) {\n            const swarmData = segments[streamSwarmId];\n            if (!(swarmData instanceof Array) ||\n                (swarmData.length !== 2) ||\n                (typeof swarmData[0] !== \"string\") ||\n                !(swarmData[1] instanceof Array)) {\n                return new Map();\n            }\n            const segmentsIds = swarmData[0].split(\"|\");\n            const segmentsStatuses = swarmData[1];\n            if (segmentsIds.length !== segmentsStatuses.length) {\n                return new Map();\n            }\n            for (let i = 0; i < segmentsIds.length; i++) {\n                const segmentStatus = segmentsStatuses[i];\n                if (typeof segmentStatus !== \"number\" || MediaPeerSegmentStatus[segmentStatus] === undefined) {\n                    return new Map();\n                }\n                segmentsMap.set(`${streamSwarmId}+${segmentsIds[i]}`, segmentStatus);\n            }\n        }\n        return segmentsMap;\n    }\n    sendCommand(command) {\n        this.debug(\"peer send command\", this.id, command, this);\n        this.peer.write(JSON.stringify(command));\n    }\n    destroy() {\n        this.debug(\"peer destroy\", this.id, this);\n        this.terminateSegmentRequest();\n        this.peer.destroy();\n    }\n    getDownloadingSegmentId() {\n        return this.downloadingSegmentId;\n    }\n    getSegmentsMap() {\n        return this.segmentsMap;\n    }\n    sendSegmentsMap(segmentsMap) {\n        this.sendCommand({ c: MediaPeerCommands.SegmentsMap, m: segmentsMap });\n    }\n    sendSegmentData(segmentId, data) {\n        this.sendCommand({\n            c: MediaPeerCommands.SegmentData,\n            i: segmentId,\n            s: data.byteLength\n        });\n        let bytesLeft = data.byteLength;\n        while (bytesLeft > 0) {\n            const bytesToSend = (bytesLeft >= this.settings.webRtcMaxMessageSize ? this.settings.webRtcMaxMessageSize : bytesLeft);\n            const buffer = buffer_1.Buffer.from(data, data.byteLength - bytesLeft, bytesToSend);\n            this.peer.write(buffer);\n            bytesLeft -= bytesToSend;\n        }\n        this.emit(\"bytes-uploaded\", this, data.byteLength);\n    }\n    sendSegmentAbsent(segmentId) {\n        this.sendCommand({ c: MediaPeerCommands.SegmentAbsent, i: segmentId });\n    }\n    requestSegment(segmentId) {\n        if (this.downloadingSegmentId) {\n            throw new Error(\"A segment is already downloading: \" + this.downloadingSegmentId);\n        }\n        this.sendCommand({ c: MediaPeerCommands.SegmentRequest, i: segmentId });\n        this.downloadingSegmentId = segmentId;\n        this.runResponseTimeoutTimer();\n    }\n    cancelSegmentRequest() {\n        let downloadingSegment;\n        if (this.downloadingSegmentId) {\n            const segmentId = this.downloadingSegmentId;\n            downloadingSegment = this.downloadingSegment ? this.downloadingSegment.pieces : undefined;\n            this.terminateSegmentRequest();\n            this.sendCommand({ c: MediaPeerCommands.CancelSegmentRequest, i: segmentId });\n        }\n        return downloadingSegment;\n    }\n    runResponseTimeoutTimer() {\n        this.timer = setTimeout(() => {\n            this.timer = null;\n            if (!this.downloadingSegmentId) {\n                return;\n            }\n            const segmentId = this.downloadingSegmentId;\n            this.cancelSegmentRequest();\n            this.emit(\"segment-timeout\", this, segmentId); // TODO: send peer not responding event\n        }, this.settings.p2pSegmentDownloadTimeout);\n    }\n    cancelResponseTimeoutTimer() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    }\n    terminateSegmentRequest() {\n        this.downloadingSegmentId = null;\n        this.downloadingSegment = null;\n        this.cancelResponseTimeoutTimer();\n    }\n}\nexports.MediaPeer = MediaPeer;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Debug = require(\"debug\");\nconst Client = require(\"bittorrent-tracker/client\");\nconst stringly_typed_event_emitter_1 = require(\"./stringly-typed-event-emitter\");\nconst media_peer_1 = require(\"./media-peer\");\nconst buffer_1 = require(\"buffer\");\nconst sha1 = require(\"sha.js/sha1\");\nconst index_1 = require(\"./index\");\nconst PEER_PROTOCOL_VERSION = 2;\nconst PEER_ID_VERSION_STRING = index_1.version.replace(/\\d*./g, v => `0${parseInt(v, 10) % 100}`.slice(-2)).slice(0, 4);\nconst PEER_ID_VERSION_PREFIX = `-WW${PEER_ID_VERSION_STRING}-`; // Using WebTorrent client ID in order to not be banned by websocket trackers\nclass PeerSegmentRequest {\n    constructor(peerId, segment) {\n        this.peerId = peerId;\n        this.segment = segment;\n    }\n}\nfunction generatePeerId() {\n    const PEER_ID_SYMBOLS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const PEER_ID_LENGTH = 20;\n    let peerId = PEER_ID_VERSION_PREFIX;\n    for (let i = 0; i < PEER_ID_LENGTH - PEER_ID_VERSION_PREFIX.length; i++) {\n        peerId += PEER_ID_SYMBOLS.charAt(Math.floor(Math.random() * PEER_ID_SYMBOLS.length));\n    }\n    return new TextEncoder().encode(peerId).buffer;\n}\nclass P2PMediaManager extends stringly_typed_event_emitter_1.STEEmitter {\n    constructor(sementsStorage, settings) {\n        super();\n        this.sementsStorage = sementsStorage;\n        this.settings = settings;\n        this.trackerClient = null;\n        this.peers = new Map();\n        this.peerCandidates = new Map();\n        this.peerSegmentRequests = new Map();\n        this.streamSwarmId = null;\n        this.debug = Debug(\"p2pml:p2p-media-manager\");\n        this.pendingTrackerClient = null;\n        this.onTrackerError = (error) => {\n            this.debug(\"tracker error\", error);\n        };\n        this.onTrackerWarning = (warning) => {\n            this.debug(\"tracker warning\", warning);\n        };\n        this.onTrackerUpdate = (data) => {\n            this.debug(\"tracker update\", data);\n            this.emit(\"tracker-update\", data);\n        };\n        this.onTrackerPeer = (trackerPeer) => {\n            this.debug(\"tracker peer\", trackerPeer.id, trackerPeer);\n            if (this.peers.has(trackerPeer.id)) {\n                this.debug(\"tracker peer already connected\", trackerPeer.id, trackerPeer);\n                trackerPeer.destroy();\n                return;\n            }\n            const peer = new media_peer_1.MediaPeer(trackerPeer, this.settings);\n            peer.on(\"connect\", this.onPeerConnect);\n            peer.on(\"close\", this.onPeerClose);\n            peer.on(\"data-updated\", this.onPeerDataUpdated);\n            peer.on(\"segment-request\", this.onSegmentRequest);\n            peer.on(\"segment-loaded\", this.onSegmentLoaded);\n            peer.on(\"segment-absent\", this.onSegmentAbsent);\n            peer.on(\"segment-error\", this.onSegmentError);\n            peer.on(\"segment-timeout\", this.onSegmentTimeout);\n            peer.on(\"bytes-downloaded\", this.onPieceBytesDownloaded);\n            peer.on(\"bytes-uploaded\", this.onPieceBytesUploaded);\n            let peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (!peerCandidatesById) {\n                peerCandidatesById = [];\n                this.peerCandidates.set(peer.id, peerCandidatesById);\n            }\n            peerCandidatesById.push(peer);\n        };\n        this.onPieceBytesDownloaded = (peer, bytes) => {\n            this.emit(\"bytes-downloaded\", bytes, peer.id);\n        };\n        this.onPieceBytesUploaded = (peer, bytes) => {\n            this.emit(\"bytes-uploaded\", bytes, peer.id);\n        };\n        this.onPeerConnect = (peer) => {\n            const connectedPeer = this.peers.get(peer.id);\n            if (connectedPeer) {\n                this.debug(\"tracker peer already connected (in peer connect)\", peer.id, peer);\n                peer.destroy();\n                return;\n            }\n            // First peer with the ID connected\n            this.peers.set(peer.id, peer);\n            // Destroy all other peer candidates\n            const peerCandidatesById = this.peerCandidates.get(peer.id);\n            if (peerCandidatesById) {\n                for (const peerCandidate of peerCandidatesById) {\n                    if (peerCandidate != peer) {\n                        peerCandidate.destroy();\n                    }\n                }\n                this.peerCandidates.delete(peer.id);\n            }\n            this.emit(\"peer-connected\", { id: peer.id, remoteAddress: peer.remoteAddress });\n        };\n        this.onPeerClose = (peer) => {\n            if (this.peers.get(peer.id) != peer) {\n                // Try to delete the peer candidate\n                const peerCandidatesById = this.peerCandidates.get(peer.id);\n                if (!peerCandidatesById) {\n                    return;\n                }\n                const index = peerCandidatesById.indexOf(peer);\n                if (index != -1) {\n                    peerCandidatesById.splice(index, 1);\n                }\n                if (peerCandidatesById.length == 0) {\n                    this.peerCandidates.delete(peer.id);\n                }\n                return;\n            }\n            for (const [key, value] of this.peerSegmentRequests) {\n                if (value.peerId == peer.id) {\n                    this.peerSegmentRequests.delete(key);\n                }\n            }\n            this.peers.delete(peer.id);\n            this.emit(\"peer-data-updated\");\n            this.emit(\"peer-closed\", peer.id);\n        };\n        this.onPeerDataUpdated = () => {\n            this.emit(\"peer-data-updated\");\n        };\n        this.onSegmentRequest = async (peer, segmentId) => {\n            if (this.masterSwarmId === undefined) {\n                return;\n            }\n            const segment = await this.sementsStorage.getSegment(segmentId, this.masterSwarmId);\n            if (segment) {\n                peer.sendSegmentData(segmentId, segment.data);\n            }\n            else {\n                peer.sendSegmentAbsent(segmentId);\n            }\n        };\n        this.onSegmentLoaded = async (peer, segmentId, data) => {\n            const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n            if (!peerSegmentRequest) {\n                return;\n            }\n            const segment = peerSegmentRequest.segment;\n            if (this.settings.segmentValidator) {\n                try {\n                    await this.settings.segmentValidator(Object.assign(Object.assign({}, segment), { data: data }), \"p2p\", peer.id);\n                }\n                catch (error) {\n                    this.debug(\"segment validator failed\", error);\n                    this.peerSegmentRequests.delete(segmentId);\n                    this.emit(\"segment-error\", segment, error, peer.id);\n                    this.onPeerClose(peer);\n                    return;\n                }\n            }\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"segment-loaded\", segment, data, peer.id);\n        };\n        this.onSegmentAbsent = (peer, segmentId) => {\n            this.peerSegmentRequests.delete(segmentId);\n            this.emit(\"peer-data-updated\");\n        };\n        this.onSegmentError = (peer, segmentId, description) => {\n            const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n            if (peerSegmentRequest) {\n                this.peerSegmentRequests.delete(segmentId);\n                this.emit(\"segment-error\", peerSegmentRequest.segment, description, peer.id);\n            }\n        };\n        this.onSegmentTimeout = (peer, segmentId) => {\n            const peerSegmentRequest = this.peerSegmentRequests.get(segmentId);\n            if (peerSegmentRequest) {\n                this.peerSegmentRequests.delete(segmentId);\n                peer.destroy();\n                if (this.peers.delete(peerSegmentRequest.peerId)) {\n                    this.emit(\"peer-data-updated\");\n                }\n            }\n        };\n        this.peerId = settings.useP2P ? generatePeerId() : new ArrayBuffer(0);\n        if (this.debug.enabled) {\n            this.debug(\"peer ID\", this.getPeerId(), new TextDecoder().decode(this.peerId));\n        }\n    }\n    getPeers() {\n        return this.peers;\n    }\n    getPeerId() {\n        return buffer_1.Buffer.from(this.peerId).toString(\"hex\");\n    }\n    async setStreamSwarmId(streamSwarmId, masterSwarmId) {\n        if (this.streamSwarmId === streamSwarmId) {\n            return;\n        }\n        this.destroy(true);\n        this.streamSwarmId = streamSwarmId;\n        this.masterSwarmId = masterSwarmId;\n        this.debug(\"stream swarm ID\", this.streamSwarmId);\n        this.pendingTrackerClient = {\n            isDestroyed: false\n        };\n        const pendingTrackerClient = this.pendingTrackerClient;\n        // TODO: native browser 'crypto.subtle' implementation doesn't work in Chrome in insecure pages\n        // TODO: Edge doesn't support SHA-1. Change to SHA-256 once Edge support is required.\n        // const infoHash = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(PEER_PROTOCOL_VERSION + this.streamSwarmId));\n        const infoHash = new sha1().update(PEER_PROTOCOL_VERSION + this.streamSwarmId).digest();\n        // destroy may be called while waiting for the hash to be calculated\n        if (!pendingTrackerClient.isDestroyed) {\n            this.pendingTrackerClient = null;\n            this.createClient(infoHash);\n        }\n        else if (this.trackerClient != null) {\n            this.trackerClient.destroy();\n            this.trackerClient = null;\n        }\n    }\n    createClient(infoHash) {\n        if (!this.settings.useP2P) {\n            return;\n        }\n        const clientOptions = {\n            infoHash: buffer_1.Buffer.from(infoHash, 0, 20),\n            peerId: buffer_1.Buffer.from(this.peerId, 0, 20),\n            announce: this.settings.trackerAnnounce,\n            rtcConfig: this.settings.rtcConfig,\n            port: 6881,\n            getAnnounceOpts: () => {\n                return { numwant: this.settings.peerRequestsPerAnnounce };\n            }\n        };\n        let oldTrackerClient = this.trackerClient;\n        this.trackerClient = new Client(clientOptions);\n        this.trackerClient.on(\"error\", this.onTrackerError);\n        this.trackerClient.on(\"warning\", this.onTrackerWarning);\n        this.trackerClient.on(\"update\", this.onTrackerUpdate);\n        this.trackerClient.on(\"peer\", this.onTrackerPeer);\n        this.trackerClient.start();\n        if (oldTrackerClient != null) {\n            oldTrackerClient.destroy();\n            oldTrackerClient = null;\n        }\n    }\n    download(segment) {\n        if (this.isDownloading(segment)) {\n            return false;\n        }\n        const candidates = [];\n        for (const peer of this.peers.values()) {\n            if ((peer.getDownloadingSegmentId() == null) &&\n                (peer.getSegmentsMap().get(segment.id) === media_peer_1.MediaPeerSegmentStatus.Loaded)) {\n                candidates.push(peer);\n            }\n        }\n        if (candidates.length === 0) {\n            return false;\n        }\n        const peer = candidates[Math.floor(Math.random() * candidates.length)];\n        peer.requestSegment(segment.id);\n        this.peerSegmentRequests.set(segment.id, new PeerSegmentRequest(peer.id, segment));\n        return true;\n    }\n    abort(segment) {\n        let downloadingSegment;\n        const peerSegmentRequest = this.peerSegmentRequests.get(segment.id);\n        if (peerSegmentRequest) {\n            const peer = this.peers.get(peerSegmentRequest.peerId);\n            if (peer) {\n                downloadingSegment = peer.cancelSegmentRequest();\n            }\n            this.peerSegmentRequests.delete(segment.id);\n        }\n        return downloadingSegment;\n    }\n    isDownloading(segment) {\n        return this.peerSegmentRequests.has(segment.id);\n    }\n    getActiveDownloadsCount() {\n        return this.peerSegmentRequests.size;\n    }\n    destroy(swarmChange = false) {\n        this.streamSwarmId = null;\n        if (this.trackerClient) {\n            this.trackerClient.stop();\n            if (swarmChange) {\n                // Don't destroy trackerClient to reuse its WebSocket connection to the tracker server\n                this.trackerClient.removeAllListeners(\"error\");\n                this.trackerClient.removeAllListeners(\"warning\");\n                this.trackerClient.removeAllListeners(\"update\");\n                this.trackerClient.removeAllListeners(\"peer\");\n            }\n            else {\n                this.trackerClient.destroy();\n                this.trackerClient = null;\n            }\n        }\n        if (this.pendingTrackerClient) {\n            this.pendingTrackerClient.isDestroyed = true;\n            this.pendingTrackerClient = null;\n        }\n        this.peers.forEach(peer => peer.destroy());\n        this.peers.clear();\n        this.peerSegmentRequests.clear();\n        for (const peerCandidateById of this.peerCandidates.values()) {\n            for (const peerCandidate of peerCandidateById) {\n                peerCandidate.destroy();\n            }\n        }\n        this.peerCandidates.clear();\n    }\n    sendSegmentsMapToAll(segmentsMap) {\n        this.peers.forEach(peer => peer.sendSegmentsMap(segmentsMap));\n    }\n    sendSegmentsMap(peerId, segmentsMap) {\n        const peer = this.peers.get(peerId);\n        if (peer) {\n            peer.sendSegmentsMap(segmentsMap);\n        }\n    }\n    getOvrallSegmentsMap() {\n        const overallSegmentsMap = new Map();\n        for (const peer of this.peers.values()) {\n            for (const [segmentId, segmentStatus] of peer.getSegmentsMap()) {\n                if (segmentStatus === media_peer_1.MediaPeerSegmentStatus.Loaded) {\n                    overallSegmentsMap.set(segmentId, media_peer_1.MediaPeerSegmentStatus.Loaded);\n                }\n                else if (!overallSegmentsMap.get(segmentId)) {\n                    overallSegmentsMap.set(segmentId, media_peer_1.MediaPeerSegmentStatus.LoadingByHttp);\n                }\n            }\n        }\n        return overallSegmentsMap;\n    }\n}\nexports.P2PMediaManager = P2PMediaManager;\n","\"use strict\";\n/**\n * Copyright 2019 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SegmentsMemoryStorage {\n    constructor(settings) {\n        this.settings = settings;\n        this.cache = new Map();\n    }\n    async storeSegment(segment) {\n        this.cache.set(segment.id, { segment, lastAccessed: performance.now() });\n    }\n    async getSegmentsMap(masterSwarmId) {\n        return this.cache;\n    }\n    async getSegment(id, masterSwarmId) {\n        const cacheItem = this.cache.get(id);\n        if (cacheItem === undefined) {\n            return undefined;\n        }\n        cacheItem.lastAccessed = performance.now();\n        return cacheItem.segment;\n    }\n    async hasSegment(id, masterSwarmId) {\n        return this.cache.has(id);\n    }\n    async clean(masterSwarmId, lockedSementsfilter) {\n        const segmentsToDelete = [];\n        const remainingSegments = [];\n        // Delete old segments\n        const now = performance.now();\n        for (const cachedSegment of this.cache.values()) {\n            if (now - cachedSegment.lastAccessed > this.settings.cachedSegmentExpiration) {\n                segmentsToDelete.push(cachedSegment.segment.id);\n            }\n            else {\n                remainingSegments.push(cachedSegment);\n            }\n        }\n        // Delete segments over cached count\n        let countOverhead = remainingSegments.length - this.settings.cachedSegmentsCount;\n        if (countOverhead > 0) {\n            remainingSegments.sort((a, b) => a.lastAccessed - b.lastAccessed);\n            for (const cachedSegment of remainingSegments) {\n                if ((lockedSementsfilter === undefined) || !lockedSementsfilter(cachedSegment.segment.id)) {\n                    segmentsToDelete.push(cachedSegment.segment.id);\n                    countOverhead--;\n                    if (countOverhead == 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        segmentsToDelete.forEach(id => this.cache.delete(id));\n        return segmentsToDelete.length > 0;\n    }\n    async destroy() {\n        this.cache.clear();\n    }\n}\nexports.SegmentsMemoryStorage = SegmentsMemoryStorage;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nclass STEEmitter extends events_1.EventEmitter {\n    on(event, listener) { return super.on(event, listener); }\n    emit(event, ...args) { return super.emit(event, ...args); }\n}\nexports.STEEmitter = STEEmitter;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst p2p_media_loader_core_1 = require(\"p2p-media-loader-core\");\nconst segment_manager_1 = require(\"./segment-manager\");\nconst hlsjs_loader_1 = require(\"./hlsjs-loader\");\nconst hlsjs_loader_class_1 = require(\"./hlsjs-loader-class\");\nclass Engine extends events_1.EventEmitter {\n    constructor(settings = {}) {\n        super();\n        this.loader = new p2p_media_loader_core_1.HybridLoader(settings.loader);\n        this.segmentManager = new segment_manager_1.SegmentManager(this.loader, settings.segments);\n        Object.keys(p2p_media_loader_core_1.Events)\n            .map(eventKey => p2p_media_loader_core_1.Events[eventKey])\n            .forEach(event => this.loader.on(event, (...args) => this.emit(event, ...args)));\n    }\n    static isSupported() {\n        return p2p_media_loader_core_1.HybridLoader.isSupported();\n    }\n    createLoaderClass() {\n        return hlsjs_loader_class_1.createHlsJsLoaderClass(hlsjs_loader_1.HlsJsLoader, this);\n    }\n    async destroy() {\n        await this.segmentManager.destroy();\n    }\n    getSettings() {\n        return {\n            segments: this.segmentManager.getSettings(),\n            loader: this.loader.getSettings()\n        };\n    }\n    getDetails() {\n        return {\n            loader: this.loader.getDetails()\n        };\n    }\n    setPlayingSegment(url, byterange, start, duration) {\n        this.segmentManager.setPlayingSegment(url, byterange, start, duration);\n    }\n    setPlayingSegmentByCurrentTime(playheadPosition) {\n        this.segmentManager.setPlayingSegmentByCurrentTime(playheadPosition);\n    }\n}\nexports.Engine = Engine;\n","/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction createHlsJsLoaderClass(HlsJsLoader, engine) {\n    function HlsJsLoaderClass() {\n        this.impl = new HlsJsLoader(engine.segmentManager);\n        this.stats = this.impl.stats;\n    }\n\n    HlsJsLoaderClass.prototype.load = function (context, config, callbacks) {\n        this.context = context;\n        this.impl.load(context, config, callbacks);\n    };\n\n    HlsJsLoaderClass.prototype.abort = function () {\n        this.impl.abort(this.context);\n    };\n\n    HlsJsLoaderClass.prototype.destroy = function () {\n        if (this.context) {\n            this.impl.abort(this.context);\n        }\n    };\n\n    HlsJsLoaderClass.getEngine = function () {\n        return engine;\n    };\n\n    return HlsJsLoaderClass;\n}\n\nmodule.exports.createHlsJsLoaderClass = createHlsJsLoaderClass;\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DEFAULT_DOWNLOAD_LATENCY = 1;\nconst DEFAULT_DOWNLOAD_BANDWIDTH = 12500; // bytes per millisecond\nclass HlsJsLoader {\n    constructor(segmentManager) {\n        this.stats = {}; // required for older versions of hls.js\n        this.segmentManager = segmentManager;\n    }\n    async load(context, _config, callbacks) {\n        if (context.type) {\n            try {\n                const result = await this.segmentManager.loadPlaylist(context.url);\n                this.successPlaylist(result, context, callbacks);\n            }\n            catch (e) {\n                this.error(e, context, callbacks);\n            }\n        }\n        else if (context.frag) {\n            try {\n                const result = await this.segmentManager.loadSegment(context.url, (context.rangeStart == undefined) || (context.rangeEnd == undefined)\n                    ? undefined\n                    : { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart });\n                if (result.content !== undefined) {\n                    setTimeout(() => this.successSegment(result.content, result.downloadBandwidth, context, callbacks), 0);\n                }\n            }\n            catch (e) {\n                setTimeout(() => this.error(e, context, callbacks), 0);\n            }\n        }\n        else {\n            console.warn(\"Unknown load request\", context);\n        }\n    }\n    abort(context) {\n        this.segmentManager.abortSegment(context.url, (context.rangeStart == undefined) || (context.rangeEnd == undefined)\n            ? undefined\n            : { offset: context.rangeStart, length: context.rangeEnd - context.rangeStart });\n    }\n    successPlaylist(xhr, context, callbacks) {\n        const now = performance.now();\n        this.stats.trequest = now - 300;\n        this.stats.tfirst = now - 200;\n        this.stats.tload = now;\n        this.stats.loaded = xhr.response.length;\n        callbacks.onSuccess({\n            url: xhr.responseURL,\n            data: xhr.response\n        }, this.stats, context);\n    }\n    successSegment(content, downloadBandwidth, context, callbacks) {\n        const now = performance.now();\n        const downloadTime = content.byteLength / (((downloadBandwidth === undefined) || (downloadBandwidth <= 0)) ? DEFAULT_DOWNLOAD_BANDWIDTH : downloadBandwidth);\n        this.stats.trequest = now - DEFAULT_DOWNLOAD_LATENCY - downloadTime;\n        this.stats.tfirst = now - downloadTime;\n        this.stats.tload = now;\n        this.stats.loaded = content.byteLength;\n        callbacks.onSuccess({\n            url: context.url,\n            data: content\n        }, this.stats, context);\n    }\n    error(error, context, callbacks) {\n        callbacks.onError(error, context);\n    }\n}\nexports.HlsJsLoader = HlsJsLoader;\n","\"use strict\";\n/**\n * @license Apache-2.0\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = \"0.6.2\";\n__export(require(\"./engine\"));\n__export(require(\"./segment-manager\"));\nfunction initHlsJsPlayer(player) {\n    if (player && player.config && player.config.loader && typeof player.config.loader.getEngine === \"function\") {\n        initHlsJsEvents(player, player.config.loader.getEngine());\n    }\n}\nexports.initHlsJsPlayer = initHlsJsPlayer;\nfunction initClapprPlayer(player) {\n    player.on(\"play\", () => {\n        const playback = player.core.getCurrentPlayback();\n        if (playback._hls && !playback._hls._p2pm_linitialized) {\n            playback._hls._p2pm_linitialized = true;\n            initHlsJsPlayer(player.core.getCurrentPlayback()._hls);\n        }\n    });\n}\nexports.initClapprPlayer = initClapprPlayer;\nfunction initFlowplayerHlsJsPlayer(player) {\n    player.on(\"ready\", () => initHlsJsPlayer(player.engine.hlsjs ? player.engine.hlsjs : player.engine.hls));\n}\nexports.initFlowplayerHlsJsPlayer = initFlowplayerHlsJsPlayer;\nfunction initVideoJsContribHlsJsPlayer(player) {\n    player.ready(() => {\n        const options = player.tech_.options_;\n        if (options && options.hlsjsConfig && options.hlsjsConfig.loader && typeof options.hlsjsConfig.loader.getEngine === \"function\") {\n            initHlsJsEvents(player.tech_, options.hlsjsConfig.loader.getEngine());\n        }\n    });\n}\nexports.initVideoJsContribHlsJsPlayer = initVideoJsContribHlsJsPlayer;\nfunction initVideoJsHlsJsPlugin() {\n    if (videojs == undefined || videojs.Html5Hlsjs == undefined) {\n        return;\n    }\n    videojs.Html5Hlsjs.addHook(\"beforeinitialize\", (videojsPlayer, hlsjs) => {\n        if (hlsjs.config && hlsjs.config.loader && typeof hlsjs.config.loader.getEngine === \"function\") {\n            initHlsJsEvents(hlsjs, hlsjs.config.loader.getEngine());\n        }\n    });\n}\nexports.initVideoJsHlsJsPlugin = initVideoJsHlsJsPlugin;\nfunction initMediaElementJsPlayer(mediaElement) {\n    mediaElement.addEventListener(\"hlsFragChanged\", (event) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine = hls.config.loader.getEngine();\n            if (event.data && (event.data.length > 1)) {\n                const frag = event.data[1].frag;\n                const byterange = (frag.byteRange.length !== 2)\n                    ? undefined\n                    : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n                engine.setPlayingSegment(frag.url, byterange, frag.start, frag.duration);\n            }\n        }\n    });\n    mediaElement.addEventListener(\"hlsDestroying\", async () => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            const engine = hls.config.loader.getEngine();\n            await engine.destroy();\n        }\n    });\n    mediaElement.addEventListener(\"hlsError\", (event) => {\n        const hls = mediaElement.hlsPlayer;\n        if (hls && hls.config && hls.config.loader && typeof hls.config.loader.getEngine === \"function\") {\n            if ((event.data !== undefined) && (event.data.details === \"bufferStalledError\")) {\n                const engine = hls.config.loader.getEngine();\n                engine.setPlayingSegmentByCurrentTime(hls.media.currentTime);\n            }\n        }\n    });\n}\nexports.initMediaElementJsPlayer = initMediaElementJsPlayer;\nfunction initJwPlayer(player, hlsjsConfig) {\n    const iid = setInterval(() => {\n        if (player.hls && player.hls.config) {\n            clearInterval(iid);\n            Object.assign(player.hls.config, hlsjsConfig);\n            initHlsJsPlayer(player.hls);\n        }\n    }, 200);\n}\nexports.initJwPlayer = initJwPlayer;\nfunction initHlsJsEvents(player, engine) {\n    player.on(\"hlsFragChanged\", (_event, data) => {\n        const frag = data.frag;\n        const byterange = (frag.byteRange.length !== 2)\n            ? undefined\n            : { offset: frag.byteRange[0], length: frag.byteRange[1] - frag.byteRange[0] };\n        engine.setPlayingSegment(frag.url, byterange, frag.start, frag.duration);\n    });\n    player.on(\"hlsDestroying\", async () => {\n        await engine.destroy();\n    });\n    player.on(\"hlsError\", (_event, errorData) => {\n        if (errorData.details === \"bufferStalledError\") {\n            const htmlMediaElement = player.media === undefined\n                ? player.el_ // videojs-contrib-hlsjs\n                : player.media; // all others\n            if (htmlMediaElement === undefined) {\n                return;\n            }\n            engine.setPlayingSegmentByCurrentTime(htmlMediaElement.currentTime);\n        }\n    });\n}\n","\"use strict\";\n/**\n * Copyright 2018 Novage LLC.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p2p_media_loader_core_1 = require(\"p2p-media-loader-core\");\nconst m3u8_parser_1 = require(\"m3u8-parser\");\nconst defaultSettings = {\n    forwardSegmentCount: 20,\n    swarmId: undefined,\n    assetsStorage: undefined,\n};\nclass SegmentManager {\n    constructor(loader, settings = {}) {\n        this.masterPlaylist = null;\n        this.variantPlaylists = new Map();\n        this.segmentRequest = null;\n        this.playQueue = [];\n        this.onSegmentLoaded = (segment) => {\n            if (this.segmentRequest && (this.segmentRequest.segmentUrl === segment.url) &&\n                (byterangeToString(this.segmentRequest.segmentByterange) === segment.range)) {\n                this.segmentRequest.onSuccess(segment.data.slice(0), segment.downloadBandwidth);\n                this.segmentRequest = null;\n            }\n        };\n        this.onSegmentError = (segment, error) => {\n            if (this.segmentRequest && (this.segmentRequest.segmentUrl === segment.url) &&\n                (byterangeToString(this.segmentRequest.segmentByterange) === segment.range)) {\n                this.segmentRequest.onError(error);\n                this.segmentRequest = null;\n            }\n        };\n        this.onSegmentAbort = (segment) => {\n            if (this.segmentRequest && (this.segmentRequest.segmentUrl === segment.url) &&\n                (byterangeToString(this.segmentRequest.segmentByterange) === segment.range)) {\n                this.segmentRequest.onError(\"Loading aborted: internal abort\");\n                this.segmentRequest = null;\n            }\n        };\n        this.settings = Object.assign(Object.assign({}, defaultSettings), settings);\n        this.loader = loader;\n        this.loader.on(p2p_media_loader_core_1.Events.SegmentLoaded, this.onSegmentLoaded);\n        this.loader.on(p2p_media_loader_core_1.Events.SegmentError, this.onSegmentError);\n        this.loader.on(p2p_media_loader_core_1.Events.SegmentAbort, this.onSegmentAbort);\n    }\n    getSettings() {\n        return this.settings;\n    }\n    processPlaylist(requestUrl, content, responseUrl) {\n        const parser = new m3u8_parser_1.Parser();\n        parser.push(content);\n        parser.end();\n        const playlist = new Playlist(requestUrl, responseUrl, parser.manifest);\n        if (playlist.manifest.playlists) {\n            this.masterPlaylist = playlist;\n            for (const [key, variantPlaylist] of this.variantPlaylists) {\n                const { streamSwarmId, found, index } = this.getStreamSwarmId(variantPlaylist.requestUrl);\n                if (!found) {\n                    this.variantPlaylists.delete(key);\n                }\n                else {\n                    variantPlaylist.streamSwarmId = streamSwarmId;\n                    variantPlaylist.streamId = \"V\" + index.toString();\n                }\n            }\n        }\n        else {\n            const { streamSwarmId, found, index } = this.getStreamSwarmId(requestUrl);\n            if (found || (this.masterPlaylist === null)) { // do not add audio and subtitles to variants\n                playlist.streamSwarmId = streamSwarmId;\n                playlist.streamId = (this.masterPlaylist === null ? undefined : \"V\" + index.toString());\n                this.variantPlaylists.set(requestUrl, playlist);\n                this.updateSegments();\n            }\n        }\n    }\n    async loadPlaylist(url) {\n        const assetsStorage = this.settings.assetsStorage;\n        let xhr;\n        if (assetsStorage !== undefined) {\n            let masterSwarmId;\n            masterSwarmId = this.getMasterSwarmId();\n            if (masterSwarmId === undefined) {\n                masterSwarmId = url.split(\"?\")[0];\n            }\n            const asset = await assetsStorage.getAsset(url, undefined, masterSwarmId);\n            if (asset !== undefined) {\n                xhr = {\n                    responseURL: asset.responseUri,\n                    response: asset.data,\n                };\n            }\n            else {\n                xhr = await this.loadContent(url, \"text\");\n                assetsStorage.storeAsset({\n                    masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : url,\n                    masterSwarmId: masterSwarmId,\n                    requestUri: url,\n                    responseUri: xhr.responseURL,\n                    data: xhr.response,\n                });\n            }\n        }\n        else {\n            xhr = await this.loadContent(url, \"text\");\n        }\n        this.processPlaylist(url, xhr.response, xhr.responseURL);\n        return xhr;\n    }\n    async loadSegment(url, byterange) {\n        const segmentLocation = this.getSegmentLocation(url, byterange);\n        const byteRangeString = byterangeToString(byterange);\n        if (!segmentLocation) {\n            let content;\n            // Not a segment from variants; usually can be: init, audio or subtitles segment, encription key etc.\n            const assetsStorage = this.settings.assetsStorage;\n            if (assetsStorage !== undefined) {\n                let masterManifestUri = this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : undefined;\n                let masterSwarmId;\n                masterSwarmId = this.getMasterSwarmId();\n                if (masterSwarmId === undefined && this.variantPlaylists.size === 1) {\n                    masterSwarmId = this.variantPlaylists.values().next().value.requestUrl.split(\"?\")[0];\n                }\n                if (masterManifestUri === undefined && this.variantPlaylists.size === 1) {\n                    masterManifestUri = this.variantPlaylists.values().next().value.requestUrl;\n                }\n                if (masterSwarmId !== undefined && masterManifestUri !== undefined) {\n                    const asset = await assetsStorage.getAsset(url, byteRangeString, masterSwarmId);\n                    if (asset !== undefined) {\n                        content = asset.data;\n                    }\n                    else {\n                        const xhr = await this.loadContent(url, \"arraybuffer\", byteRangeString);\n                        content = xhr.response;\n                        assetsStorage.storeAsset({\n                            masterManifestUri: masterManifestUri,\n                            masterSwarmId: masterSwarmId,\n                            requestUri: url,\n                            requestRange: byteRangeString,\n                            responseUri: xhr.responseURL,\n                            data: content,\n                        });\n                    }\n                }\n            }\n            if (content === undefined) {\n                const xhr = await this.loadContent(url, \"arraybuffer\", byteRangeString);\n                content = xhr.response;\n            }\n            return { content, downloadBandwidth: 0 };\n        }\n        const segmentSequence = (segmentLocation.playlist.manifest.mediaSequence ? segmentLocation.playlist.manifest.mediaSequence : 0)\n            + segmentLocation.segmentIndex;\n        if (this.playQueue.length > 0) {\n            const previousSegment = this.playQueue[this.playQueue.length - 1];\n            if (previousSegment.segmentSequence !== segmentSequence - 1) {\n                // Reset play queue in case of segment loading out of sequence\n                this.playQueue = [];\n            }\n        }\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Cancel segment request: simultaneous segment requests are not supported\");\n        }\n        const promise = new Promise((resolve, reject) => {\n            this.segmentRequest = new SegmentRequest(url, byterange, segmentSequence, segmentLocation.playlist.requestUrl, (content, downloadBandwidth) => resolve({ content, downloadBandwidth }), error => reject(error));\n        });\n        this.playQueue.push({ segmentUrl: url, segmentByterange: byterange, segmentSequence: segmentSequence });\n        this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, true);\n        return promise;\n    }\n    setPlayingSegment(url, byterange, start, duration) {\n        const urlIndex = this.playQueue.findIndex(segment => (segment.segmentUrl == url) && compareByterange(segment.segmentByterange, byterange));\n        if (urlIndex >= 0) {\n            this.playQueue = this.playQueue.slice(urlIndex);\n            this.playQueue[0].playPosition = { start, duration };\n            this.updateSegments();\n        }\n    }\n    setPlayingSegmentByCurrentTime(playheadPosition) {\n        if (this.playQueue.length === 0 || !this.playQueue[0].playPosition) {\n            return;\n        }\n        const currentSegmentPosition = this.playQueue[0].playPosition;\n        const segmentEndTime = currentSegmentPosition.start + currentSegmentPosition.duration;\n        if (segmentEndTime - playheadPosition < 0.2) {\n            // means that current segment is (almost) finished playing\n            // remove it from queue\n            this.playQueue = this.playQueue.slice(1);\n            this.updateSegments();\n        }\n    }\n    abortSegment(url, byterange) {\n        if (this.segmentRequest && (this.segmentRequest.segmentUrl === url) &&\n            compareByterange(this.segmentRequest.segmentByterange, byterange)) {\n            this.segmentRequest.onSuccess(undefined, 0);\n            this.segmentRequest = null;\n        }\n    }\n    async destroy() {\n        if (this.segmentRequest) {\n            this.segmentRequest.onError(\"Loading aborted: object destroyed\");\n            this.segmentRequest = null;\n        }\n        this.masterPlaylist = null;\n        this.variantPlaylists.clear();\n        this.playQueue = [];\n        if (this.settings.assetsStorage !== undefined) {\n            await this.settings.assetsStorage.destroy();\n        }\n        await this.loader.destroy();\n    }\n    updateSegments() {\n        if (!this.segmentRequest) {\n            return;\n        }\n        const segmentLocation = this.getSegmentLocation(this.segmentRequest.segmentUrl, this.segmentRequest.segmentByterange);\n        if (segmentLocation) {\n            this.loadSegments(segmentLocation.playlist, segmentLocation.segmentIndex, false);\n        }\n    }\n    getSegmentLocation(url, byterange) {\n        for (const playlist of this.variantPlaylists.values()) {\n            const segmentIndex = playlist.getSegmentIndex(url, byterange);\n            if (segmentIndex >= 0) {\n                return { playlist: playlist, segmentIndex: segmentIndex };\n            }\n        }\n        return undefined;\n    }\n    async loadSegments(playlist, segmentIndex, requestFirstSegment) {\n        const segments = [];\n        const playlistSegments = playlist.manifest.segments;\n        const initialSequence = playlist.manifest.mediaSequence ? playlist.manifest.mediaSequence : 0;\n        let loadSegmentId = null;\n        let priority = Math.max(0, this.playQueue.length - 1);\n        const masterSwarmId = this.getMasterSwarmId();\n        for (let i = segmentIndex; i < playlistSegments.length && segments.length < this.settings.forwardSegmentCount; ++i) {\n            const segment = playlist.manifest.segments[i];\n            const url = playlist.getSegmentAbsoluteUrl(segment.uri);\n            const byterange = segment.byterange;\n            const id = this.getSegmentId(playlist, initialSequence + i);\n            segments.push({\n                id: id,\n                url: url,\n                masterSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlist.streamSwarmId,\n                masterManifestUri: this.masterPlaylist !== null ? this.masterPlaylist.requestUrl : playlist.requestUrl,\n                streamId: playlist.streamId,\n                sequence: (initialSequence + i).toString(),\n                range: byterangeToString(byterange),\n                priority: priority++,\n            });\n            if (requestFirstSegment && !loadSegmentId) {\n                loadSegmentId = id;\n            }\n        }\n        this.loader.load(segments, playlist.streamSwarmId);\n        if (loadSegmentId) {\n            const segment = await this.loader.getSegment(loadSegmentId);\n            if (segment) { // Segment already loaded by loader\n                this.onSegmentLoaded(segment);\n            }\n        }\n    }\n    getSegmentId(playlist, segmentSequence) {\n        return `${playlist.streamSwarmId}+${segmentSequence}`;\n    }\n    getMasterSwarmId() {\n        const settingsSwarmId = (this.settings.swarmId && (this.settings.swarmId.length !== 0)) ? this.settings.swarmId : undefined;\n        if (settingsSwarmId !== undefined) {\n            return settingsSwarmId;\n        }\n        return (this.masterPlaylist !== null)\n            ? this.masterPlaylist.requestUrl.split(\"?\")[0]\n            : undefined;\n    }\n    getStreamSwarmId(playlistUrl) {\n        const masterSwarmId = this.getMasterSwarmId();\n        if (this.masterPlaylist !== null) {\n            for (let i = 0; i < this.masterPlaylist.manifest.playlists.length; ++i) {\n                const url = new URL(this.masterPlaylist.manifest.playlists[i].uri, this.masterPlaylist.responseUrl).toString();\n                if (url === playlistUrl) {\n                    return { streamSwarmId: `${masterSwarmId}+V${i}`, found: true, index: i };\n                }\n            }\n        }\n        return {\n            streamSwarmId: masterSwarmId !== undefined ? masterSwarmId : playlistUrl.split(\"?\")[0],\n            found: false,\n            index: -1\n        };\n    }\n    async loadContent(url, responseType, range) {\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, true);\n            xhr.responseType = responseType;\n            if (range) {\n                xhr.setRequestHeader(\"Range\", range);\n            }\n            xhr.addEventListener(\"readystatechange\", () => {\n                if (xhr.readyState !== 4) {\n                    return;\n                }\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    resolve(xhr);\n                }\n                else {\n                    reject(xhr.statusText);\n                }\n            });\n            const xhrSetup = this.loader.getSettings().xhrSetup;\n            if (xhrSetup) {\n                xhrSetup(xhr, url);\n            }\n            xhr.send();\n        });\n    }\n}\nexports.SegmentManager = SegmentManager;\nclass Playlist {\n    constructor(requestUrl, responseUrl, manifest) {\n        this.requestUrl = requestUrl;\n        this.responseUrl = responseUrl;\n        this.manifest = manifest;\n        this.streamSwarmId = \"\";\n    }\n    getSegmentIndex(url, byterange) {\n        for (let i = 0; i < this.manifest.segments.length; ++i) {\n            const segment = this.manifest.segments[i];\n            const segmentUrl = this.getSegmentAbsoluteUrl(segment.uri);\n            if ((url === segmentUrl) && compareByterange(segment.byterange, byterange)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getSegmentAbsoluteUrl(segmentUrl) {\n        return new URL(segmentUrl, this.responseUrl).toString();\n    }\n}\nclass SegmentRequest {\n    constructor(segmentUrl, segmentByterange, segmentSequence, playlistRequestUrl, onSuccess, onError) {\n        this.segmentUrl = segmentUrl;\n        this.segmentByterange = segmentByterange;\n        this.segmentSequence = segmentSequence;\n        this.playlistRequestUrl = playlistRequestUrl;\n        this.onSuccess = onSuccess;\n        this.onError = onError;\n    }\n}\nfunction compareByterange(b1, b2) {\n    return (b1 === undefined)\n        ? (b2 === undefined)\n        : ((b2 !== undefined) && (b1.length === b2.length) && (b1.offset === b2.offset));\n}\nfunction byterangeToString(byterange) {\n    if (byterange === undefined) {\n        return undefined;\n    }\n    const end = byterange.offset + byterange.length - 1;\n    return `bytes=${byterange.offset}-${end}`;\n}\n","var Buffer = require('safe-buffer').Buffer\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n","/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = require('inherits')\nvar Hash = require('./hash')\nvar Buffer = require('safe-buffer').Buffer\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n"],"sourceRoot":""}